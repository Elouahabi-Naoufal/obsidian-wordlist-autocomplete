/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => WordlistAutocompletePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var WordlistSuggest = class extends import_obsidian.EditorSuggest {
  constructor(plugin) {
    super(plugin.app);
    this.words = [];
    this.plugin = plugin;
    this.loadWordlist();
  }
  shorthand(word) {
    if (!word) return word;
    const first = word[0];
    const rest = word.slice(1).replace(/[aeiouAEIOU]/g, '');
    return first + rest;
  }
  
  async loadWordlist() {
    this.words = [];
    this.shorthandMap = new Map();
    
    for (const filename of this.plugin.settings.selectedWordlists) {
      try {
        const file = this.plugin.app.vault.getAbstractFileByPath(filename);
        if (file instanceof import_obsidian.TFile) {
          const content = await this.plugin.app.vault.read(file);
          const fileWords = content.split(/\r?\n/).filter((word) => word.trim().length > 0);
          this.words.push(...fileWords);
        }
      } catch (error) {
        console.error(`Failed to load wordlist ${filename}:`, error);
      }
    }
    
    this.words = [...new Set(this.words)];
    
    // Build shorthand mapping
    for (const word of this.words) {
      const key = this.shorthand(word).toLowerCase();
      if (!this.shorthandMap.has(key)) {
        this.shorthandMap.set(key, []);
      }
      this.shorthandMap.get(key).push(word);
    }
  }
  onTrigger(cursor, editor) {
    const line = editor.getLine(cursor.line);
    const beforeCursor = line.substring(0, cursor.ch);
    const minLength = this.plugin.settings.minLetters;
    const match = beforeCursor.match(new RegExp(`\\b(\\w{${minLength},})$`));
    if (match) {
      return {
        start: { line: cursor.line, ch: cursor.ch - match[1].length },
        end: cursor,
        query: match[1]
      };
    }
    return null;
  }
  getSuggestions(context) {
    const query = context.query.toLowerCase();
    const matches = new Set();
    
    // Direct prefix matches
    for (const word of this.words) {
      if (word.toLowerCase().startsWith(query)) {
        matches.add(word);
      }
    }
    
    // Shorthand matches (if enabled)
    if (this.plugin.settings.enableShorthand) {
      for (const [shortKey, wordList] of this.shorthandMap) {
        if (shortKey.startsWith(query)) {
          wordList.forEach(word => matches.add(word));
        }
      }
    }
    
    return Array.from(matches).slice(0, 10).map((word) => ({ word }));
  }
  renderSuggestion(suggestion, el) {
    el.createEl("div", { text: suggestion.word });
  }
  selectSuggestion(suggestion, evt) {
    const { context } = this;
    if (context) {
      const editor = context.editor;
      let insertWord = suggestion.word;
      
      if (this.plugin.settings.preserveCase) {
        const query = context.query;
        if (query === query.toUpperCase()) {
          insertWord = suggestion.word.toUpperCase();
        } else if (query === query.toLowerCase()) {
          insertWord = suggestion.word.toLowerCase();
        } else if (query[0] === query[0].toUpperCase()) {
          insertWord = suggestion.word[0].toUpperCase() + suggestion.word.slice(1).toLowerCase();
        }
      }
      
      editor.replaceRange(insertWord + " ", context.start, context.end);
    }
  }
};
var DEFAULT_SETTINGS = {
  minLetters: 3,
  selectedWordlists: ["mega_wordlist.txt"],
  enableShorthand: true,
  preserveCase: false
};
var WordlistAutocompletePlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.suggestor = new WordlistSuggest(this);
    this.registerEditorSuggest(this.suggestor);
    this.addSettingTab(new WordlistSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  
  async reloadWordlists() {
    if (this.suggestor) {
      await this.suggestor.loadWordlist();
    }
  }
};
var FileSelectionModal = class extends import_obsidian.Modal {
  constructor(app, files, selectedFiles, onSubmit) {
    super(app);
    this.files = files;
    this.selectedFiles = [...selectedFiles];
    this.onSubmit = onSubmit;
  }
  
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Select wordlist files" });
    
    this.files.forEach(file => {
      const setting = new import_obsidian.Setting(contentEl)
        .setName(file.name)
        .setDesc(file.path)
        .addToggle(toggle => toggle
          .setValue(this.selectedFiles.includes(file.path))
          .onChange(value => {
            if (value) {
              if (!this.selectedFiles.includes(file.path)) {
                this.selectedFiles.push(file.path);
              }
            } else {
              this.selectedFiles = this.selectedFiles.filter(f => f !== file.path);
            }
          }));
    });
    
    new import_obsidian.Setting(contentEl)
      .addButton(btn => btn.setButtonText("Save").setCta().onClick(() => {
        this.onSubmit(this.selectedFiles);
        this.close();
      }))
      .addButton(btn => btn.setButtonText("Cancel").onClick(() => this.close()));
  }
  
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

var WordlistSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  
  updateSelectedFilesList(container) {
    container.empty();
    if (this.plugin.settings.selectedWordlists.length === 0) {
      container.createEl("div", { text: "No files selected", cls: "setting-item-description" });
    } else {
      this.plugin.settings.selectedWordlists.forEach(file => {
        container.createEl("div", { text: file, cls: "setting-item-description" });
      });
    }
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Wordlist Autocomplete Settings" });
    new import_obsidian.Setting(containerEl).setName("Minimum letters to trigger").setDesc("Number of letters needed before autocomplete appears").addSlider((slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.minLetters).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.minLetters = value;
      await this.plugin.saveSettings();
    }));
    
    new import_obsidian.Setting(containerEl).setName("Enable shorthand matching").setDesc("Allow typing 'orcl' to match 'Oracle' (removes vowels except first letter)").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableShorthand).onChange(async (value) => {
      this.plugin.settings.enableShorthand = value;
      await this.plugin.saveSettings();
    }));
    
    new import_obsidian.Setting(containerEl).setName("Preserve case").setDesc("Match the case of your input: 'ORACLE' → 'ORACLE', 'oracle' → 'oracle', 'Oracle' → 'Oracle'").addToggle((toggle) => toggle.setValue(this.plugin.settings.preserveCase).onChange(async (value) => {
      this.plugin.settings.preserveCase = value;
      await this.plugin.saveSettings();
    }));
    
    const wordlistSetting = new import_obsidian.Setting(containerEl).setName("Wordlist files").setDesc("Select .txt files to use for autocomplete");
    
    const selectedFilesDiv = wordlistSetting.controlEl.createDiv();
    this.updateSelectedFilesList(selectedFilesDiv);
    
    wordlistSetting.addButton((button) => button.setButtonText("Browse files").onClick(async () => {
      const txtFiles = this.plugin.app.vault.getFiles().filter(file => file.extension === "txt");
      const modal = new FileSelectionModal(this.plugin.app, txtFiles, this.plugin.settings.selectedWordlists, async (selected) => {
        this.plugin.settings.selectedWordlists = selected;
        await this.plugin.saveSettings();
        await this.plugin.suggestor.loadWordlist();
        this.updateSelectedFilesList(selectedFilesDiv);
      });
      modal.open();
    }));
  }
};
